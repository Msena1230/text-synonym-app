import { firebaseConfig } from './firebase-config.js';
import { initializeApp } from 'https://www.gstatic.com/firebasejs/9.22.1/firebase-app.js';
import { getAuth, GoogleAuthProvider, signInWithPopup, onAuthStateChanged, signOut } from 'https://www.gstatic.com/firebasejs/9.22.1/firebase-auth.js';
import { getFirestore, doc, getDoc, setDoc } from 'https://www.gstatic.com/firebasejs/9.22.1/firebase-firestore.js';


document.addEventListener('DOMContentLoaded', () => {


    // --- Firebase Initialization ---
    const app = initializeApp(firebaseConfig);
    const auth = getAuth(app);
    const db = getFirestore(app);


    // --- Splash Screen Logic ---
    const splashScreen = document.getElementById('splash-screen');
    const line1 = document.getElementById('splash-text-line1');
    const line2 = document.getElementById('splash-text-line2');
    line1.textContent = line1.dataset.text;
    line2.textContent = line2.dataset.text;
    setTimeout(() => { line1.classList.add('active'); }, 200);
    setTimeout(() => { line2.classList.add('active'); }, 1700);
    setTimeout(() => { splashScreen.classList.add('hidden'); }, 3200);

    const stopWords = new Set([
        'a', 'an', 'the', 'in', 'on', 'at', 'for', 'to', 'of',
        'i', 'you', 'he', 'she', 'it', 'we', 'they', 'me', 'him', 'her', 'us', 'them',
        'my', 'your', 'his', 'its', 'our', 'their',
        'is', 'am', 'are', 'was', 'were', 'be', 'been', 'being',
        'and', 'but', 'or', 'so', 'if', 'because', 'as', 'while', 'with', 'by', 'from',
        'not', 'no', 'up', 'out', 'then', 'what', 'when', 'where', 'who', 'which', 'how', 'why',
        'this', 'that', 'these', 'those', 'here', 'there'
    ]);

    // --- DOM Elements ---
    const textInput = document.getElementById('text-input');
    const processButton = document.getElementById('process-button');
    const processedText = document.getElementById('processed-text');
    const synonymList = document.getElementById('synonym-list');
    const wordCounter = document.getElementById('word-counter');
    const clearTextButton = document.getElementById('clear-text-button');
    const copyOutputButton = document.getElementById('copy-output-button');
    const aiDetectButton = document.getElementById('ai-detect-button');
    const historyPanel = document.querySelector('.history-panel');
    const historyList = document.getElementById('history-list');
    const clearHistoryButton = document.getElementById('clear-history-button');
    const settingsButton = document.getElementById('settings-button');
    const settingsModal = document.getElementById('settings-modal');
    const closeSettingsModalButton = document.getElementById('close-settings-modal');
    const apiKeyInput = document.getElementById('api-key-input');
    const saveApiKeyButton = document.getElementById('save-api-key');
    const saplingApiKeyInput = document.getElementById('sapling-api-key-input');
    const saveSaplingApiKeyButton = document.getElementById('save-sapling-api-key');
    const saveSaplingApiKeyFeedback = document.getElementById('save-sapling-api-key-feedback');
    const themePreviewButtons = document.querySelectorAll('.theme-preview-button');
    const modelSelectButtons = document.querySelectorAll('.model-select-button');
    const layoutModeToggle = document.getElementById('layout-mode-toggle');
    const translationLanguageSelect = document.getElementById('translation-language-select');
    const bookmarkListButton = document.getElementById('bookmark-list-button');
    const bookmarkModal = document.getElementById('bookmark-modal');
    const closeBookmarkModalButton = document.getElementById('close-bookmark-modal');
    const bookmarkList = document.getElementById('bookmark-list');
    const startFlashcardsButton = document.getElementById('start-flashcards-button');
    const progressContainer = document.getElementById('progress-container');
    const progressBar = document.getElementById('progress-bar');
    const progressMessage = document.getElementById('progress-message');
    const loginButton = document.getElementById('login-button');
    const logoutButton = document.getElementById('logout-button');
    const userProfile = document.getElementById('user-profile');
    const guestView = document.getElementById('guest-view');
    const userName = document.getElementById('user-name');
    const notificationModal = document.getElementById('notification-modal');
    const notificationTitle = document.getElementById('notification-title');
    const notificationMessage = document.getElementById('notification-message');
    const notificationCloseButton = document.getElementById('notification-close-button');
    const devLoginButton = document.getElementById('dev-login-button');

    const devPasswordInput = document.getElementById('dev-password');
    const devLoginFeedback = document.getElementById('dev-login-feedback');
    const developerLoginContainer = document.getElementById('developer-login-container');
    const developerMemoContainer = document.getElementById('developer-memo-container');
    const devMemoPad = document.getElementById('dev-memo-pad');




    let geminiApiKey = '';
    let isDevLoggedIn = false; // Tracks if developer has logged in

    let saplingApiKey = '';
    let history = [];
    let activeHistoryId = null;
    let messageIntervalId = null;
    let progressIntervalId = null;
    let selectedModel = 'gemini-2.5-flash-lite';
    let selectedTranslationLanguage = 'Japanese';

    const loadingMessages = [
        'Working on it...', 'Analyzing your text...', 'Asking the AI for suggestions!',
        'Still in progress...', 'Fetching synonyms...', 'Just a moment longer!',
        'Compiling the results...', 'Almost there!'
    ];

    // --- Notification Logic ---
    const showNotification = (title, message) => {
        notificationTitle.textContent = title;
        notificationMessage.textContent = message;
        notificationModal.classList.remove('hidden');
    };

    const closeNotification = () => {
        notificationModal.classList.add('hidden');
    };

    notificationCloseButton.addEventListener('click', closeNotification);
    notificationModal.addEventListener('click', (e) => { 
        if (e.target === notificationModal) closeNotification(); 
    });

    // --- Usage Limit for Guests ---
    const checkUsageLimit = () => {
        if (auth.currentUser) return true;
        const usageData = JSON.parse(localStorage.getItem('guestUsage') || '{}');
        const today = new Date().toISOString().split('T')[0];
        if (usageData.date === today && usageData.count >= 1) {
            showNotification('Daily Limit Reached', 'You have reached the daily limit for guest users. Please sign in for unlimited use.');
            return false;
        }
        return true;
    };

    const recordUsage = () => {
        if (auth.currentUser) return;
        const usageData = JSON.parse(localStorage.getItem('guestUsage') || '{}');
        const today = new Date().toISOString().split('T')[0];
        if (usageData.date === today) {
            usageData.count = (usageData.count || 0) + 1;
        } else {
            usageData.date = today;
            usageData.count = 1;
        }
        localStorage.setItem('guestUsage', JSON.stringify(usageData));
    };

    // --- Firebase Auth & Data Sync Logic ---
    onAuthStateChanged(auth, async (user) => {
        if (user) {
            userProfile.classList.remove('hidden');
            guestView.classList.add('hidden');
            userName.textContent = user.displayName;
            historyPanel.style.display = 'flex';
            await loadDataFromFirestore(user);
        } else {
            userProfile.classList.add('hidden');
            guestView.classList.remove('hidden');
            userName.textContent = '';
            
            // --- Guest Mode: History Disabled ---
            history = [];
            historyList.innerHTML = '<p class="placeholder">Please log in to use the history feature.</p>';
            historyPanel.style.display = 'none';

            const localBookmarks = JSON.parse(localStorage.getItem('bookmarkedWords') || '[]');
            saveBookmarks(localBookmarks, false);
            
            loadTheme();
            loadLayoutMode();
            loadModel();
            loadTranslationLanguage();
            loadSaplingApiKey();
        }
    });

    const loadDataFromFirestore = async (user) => {
        const userDocRef = doc(db, "users", user.uid);
        try {
            const docSnap = await getDoc(userDocRef);
            if (docSnap.exists()) {
                const data = docSnap.data();
                history = data.history || [];
                saveBookmarks(data.bookmarks || [], false);
                const userSettings = data.settings || {};
                applyTheme(userSettings.theme || 'light');
                applyLayoutMode(userSettings.layoutMode || false);
                selectedModel = userSettings.selectedModel || 'gemini-2.5-flash-lite';
                selectedTranslationLanguage = userSettings.translationLanguage || 'Japanese';
                saplingApiKey = userSettings.saplingApiKey || '';
                updateSelectedThemeButton(userSettings.theme || 'light');
                updateSelectedModelButton();
                translationLanguageSelect.value = selectedTranslationLanguage;
                saplingApiKeyInput.value = saplingApiKey;
                geminiApiKey = userSettings.geminiApiKey || '';
                apiKeyInput.value = geminiApiKey;
            } else {
                console.log("Creating new user document in Firestore.");
                saveUserData();
            }
            renderHistory();
        } catch (error) {
            console.error("Error loading data from Firestore: ", error);
            loadHistory();
            renderBookmarks();
        }
    };

    const saveUserData = async () => {
        const user = auth.currentUser;
        if (!user) return;
        const userDocRef = doc(db, "users", user.uid);
        const dataToSave = {
            history: history,
            bookmarks: getBookmarks(),
            settings: {
                theme: localStorage.getItem('theme') || 'light',
                layoutMode: localStorage.getItem('layoutMode') === 'true',
                selectedModel: localStorage.getItem('ai_humanizer_selected_model') || 'gemini-2.5-flash-lite',
                translationLanguage: localStorage.getItem('translationLanguage') || 'Japanese',
                saplingApiKey: localStorage.getItem('saplingApiKey') || '',
                geminiApiKey: localStorage.getItem('geminiApiKey') || ''
            }
        };
        try {
            await setDoc(userDocRef, dataToSave, { merge: true });
            console.log('User data saved to Firestore');
        } catch (error) {
            console.error("Error saving user data to Firestore: ", error);
        }
    };

    loginButton.addEventListener('click', () => {
        const provider = new GoogleAuthProvider();
        signInWithPopup(auth, provider).catch(error => {
            console.error('Login failed', error);
            alert(`Login failed: ${error.message}`);
        });
    });

    logoutButton.addEventListener('click', () => {
        signOut(auth).catch(error => console.error('Logout failed', error));
    });

    // --- History Logic ---
    const saveHistory = () => {
        if (!auth.currentUser) return;
        localStorage.setItem('synonymFinderHistory', JSON.stringify(history));
        saveUserData();
    };

    const getHistoryGroup = (timestamp) => {
        const now = new Date();
        const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
        const yesterday = new Date(today);
        yesterday.setDate(yesterday.getDate() - 1);
        const thisWeek = new Date(today);
        thisWeek.setDate(thisWeek.getDate() - now.getDay());
        const thisMonth = new Date(now.getFullYear(), now.getMonth(), 1);
        const date = new Date(timestamp);
        if (date >= today) return 'Today';
        if (date >= yesterday) return 'Yesterday';
        if (date >= thisWeek) return 'This Week';
        if (date >= thisMonth) return 'This Month';
        return 'Older';
    };

    const renderHistory = () => {
        if (!auth.currentUser) {
            // historyList.innerHTML = '<p class="placeholder">Please log in to use the history feature.</p>';
            // return;
        }
        historyList.innerHTML = '';
        if (history.length === 0) {
            historyList.innerHTML = `<p class="placeholder">Your history will appear here.</p>`;
            return;
        }
        const groupedHistory = { Today: [], Yesterday: [], 'This Week': [], 'This Month': [], Older: [] };
        history.forEach(item => {
            const group = getHistoryGroup(item.id);
            groupedHistory[group].push(item);
        });
        Object.keys(groupedHistory).forEach(groupName => {
            const groupItems = groupedHistory[groupName];
            if (groupItems.length > 0) {
                const header = document.createElement('h5');
                header.className = 'history-group-header';
                header.textContent = groupName;
                historyList.appendChild(header);
                // As requested by the user, the rendering logic for history items is commented out when not logged in.
                // This logic is now controlled by the `if (!auth.currentUser)` check at the beginning of the function.
                groupItems.forEach(item => {
                    const historyItem = document.createElement('div');
                    historyItem.className = 'history-item';
                    historyItem.dataset.id = item.id;
                    if (item.id === activeHistoryId) {
                        historyItem.classList.add('active');
                    }
                    const textSpan = document.createElement('span');
                    textSpan.className = 'history-item-text';
                    textSpan.textContent = item.customTitle || (item.text.substring(0, 50) + (item.text.length > 50 ? '...' : ''));
                    historyItem.appendChild(textSpan);
                    const buttonsDiv = document.createElement('div');
                    buttonsDiv.className = 'history-item-buttons';
                    const renameBtn = document.createElement('button');
                    renameBtn.className = 'rename-history-item-btn';
                    renameBtn.innerHTML = '<i class="fas fa-pencil-alt"></i>';
                    renameBtn.title = 'Rename this item';
                    renameBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        startRename(historyItem, item.id);
                    });
                    buttonsDiv.appendChild(renameBtn);
                    const deleteBtn = document.createElement('button');
                    deleteBtn.className = 'delete-history-item-btn';
                    deleteBtn.innerHTML = '<i class="fas fa-times"></i>';
                    deleteBtn.title = 'Delete this item';
                    deleteBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        if (confirm('Are you sure you want to delete this item?')) {
                            deleteHistoryItem(item.id);
                        }
                    });
                    buttonsDiv.appendChild(deleteBtn);
                    historyItem.appendChild(buttonsDiv);
                    historyItem.addEventListener('click', () => {
                        if (historyItem.querySelector('input')) return;
                        loadHistoryItem(item.id);
                    });
                    historyList.appendChild(historyItem);
                });
            }
        });
    };

    const startRename = (historyItem, itemId) => {
        const textSpan = historyItem.querySelector('.history-item-text');
        const currentTitle = textSpan.textContent;
        const input = document.createElement('input');
        input.type = 'text';
        input.className = 'history-item-input';
        input.value = currentTitle;
        const save = () => {
            const newTitle = input.value.trim();
            if (newTitle && newTitle !== currentTitle) {
                saveNewTitle(itemId, newTitle);
            } else {
                renderHistory();
            }
        };
        input.addEventListener('blur', save);
        input.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                input.blur();
            } else if (e.key === 'Escape') {
                renderHistory();
            }
        });
        historyItem.replaceChild(input, textSpan);
        input.focus();
        input.select();
    };

    const saveNewTitle = (itemId, newTitle) => {
        const itemIndex = history.findIndex(item => item.id === itemId);
        if (itemIndex > -1) {
            history[itemIndex].customTitle = newTitle;
            saveHistory();
            renderHistory();
        }
    };

    const addHistoryItem = (text, parts, synonymData) => {
        if (!auth.currentUser) return;
        if (!text || !text.trim()) return;
        const newItem = { id: Date.now(), text, parts, synonymData };
        const existingIndex = history.findIndex(item => item.text === text);
        if (existingIndex > -1) {
            history.splice(existingIndex, 1);
        }
        history.unshift(newItem);
        activeHistoryId = newItem.id;
        if (history.length > 100) {
            history = history.slice(0, 100);
        }
        saveHistory();
        renderHistory();
    };

    const loadHistoryItem = (id) => {
        const item = history.find(h => h.id === id);
        if (item) {
            textInput.value = item.text;
            activeHistoryId = id;
            if (item.synonymData && item.parts) {
                renderSynonymCandidates(item.synonymData, item.parts);
            } else {
                processedText.innerHTML = '';
                synonymList.innerHTML = '<p class="placeholder">No synonym data saved. Process again.</p>';
            }
            textInput.style.zIndex = -1;
            processedText.style.zIndex = 1;
            renderHistory();
            textInput.dispatchEvent(new Event('input', { bubbles: true }));
        }
    };

    const deleteHistoryItem = (id) => {
        history = history.filter(item => item.id !== id);
        if (activeHistoryId === id) {
            activeHistoryId = null;
            textInput.value = '';
            processedText.innerHTML = '';
        }
        saveHistory();
        renderHistory();
    };

    const clearHistory = () => {
        if (confirm('Are you sure you want to clear all history?')) {
            history = [];
            activeHistoryId = null;
            textInput.value = '';
            processedText.innerHTML = '';
            saveHistory();
            renderHistory();
        }
    };

    const loadHistory = () => {
        history = JSON.parse(localStorage.getItem('synonymFinderHistory') || '[]');
        renderHistory();
    };

    clearHistoryButton.addEventListener('click', clearHistory);

    // --- Bookmarks & Flashcards Logic ---
    const getBookmarks = () => JSON.parse(localStorage.getItem('bookmarkedWords') || '[]');

    const saveBookmarks = (bookmarks, doSaveUser = true) => {
        localStorage.setItem('bookmarkedWords', JSON.stringify(bookmarks));
        startFlashcardsButton.style.display = bookmarks.length > 0 ? 'block' : 'none';
        renderBookmarks();
        if(doSaveUser) saveUserData();
    };

    function renderBookmarks() {
        const bookmarks = getBookmarks();
        bookmarkList.innerHTML = '';
        if (bookmarks.length === 0) {
            bookmarkList.innerHTML = '<p class="placeholder">No words bookmarked yet.</p>';
            startFlashcardsButton.style.display = 'none';
            return;
        }
        startFlashcardsButton.style.display = 'block';
        bookmarks.forEach(bookmark => {
            const item = document.createElement('div');
            item.className = 'bookmark-item';
            const synonymsHTML = bookmark.synonyms.map(s => `<li>${s.word} <span class="translation">(${s.translation})</span></li>`).join('');
            item.innerHTML = `
                <div class="bookmark-item-content">
                    <div class="original">${bookmark.originalWord} <span class="pos">(${bookmark.pos})</span><span class="translation">(${bookmark.meaning || bookmark.translation || ''})</span></div>
                    <ul class="bookmark-synonyms">${synonymsHTML}</ul>
                </div>
                <button class="remove-bookmark-btn" data-word="${bookmark.originalWord}" data-context="${bookmark.context_phrase}"><i class="fas fa-trash-alt"></i></button>
            `;
            bookmarkList.appendChild(item);
        });
        document.querySelectorAll('.remove-bookmark-btn').forEach(button => {
            button.addEventListener('click', (e) => {
                const wordToRemove = e.currentTarget.dataset.word;
                const contextToRemove = e.currentTarget.dataset.context;
                let currentBookmarks = getBookmarks();
                currentBookmarks = currentBookmarks.filter(b => !(b.originalWord === wordToRemove && b.context_phrase === contextToRemove));
                saveBookmarks(currentBookmarks);
            });
        });
    }

    const shuffleArray = (array) => {
        for (let i = array.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [array[i], array[j]] = [array[j], array[i]];
        }
        return array;
    };

    const flashcardModal = document.getElementById('flashcard-modal');
    const closeFlashcardModalButton = document.getElementById('close-flashcard-modal');
    const flashcard = document.getElementById('flashcard');
    const flashcardFront = document.querySelector('.flashcard-front');
    const flashcardBack = document.querySelector('.flashcard-back');
    const prevFlashcardButton = document.getElementById('prev-flashcard-button');
    const nextFlashcardButton = document.getElementById('next-flashcard-button');
    const completeFlashcardButton = document.getElementById('complete-flashcard-button');
    const flashcardProgress = document.getElementById('flashcard-progress');
    let flashcardQuiz = [];
    let currentFlashcardIndex = 0;

    const openFlashcardModal = () => {
        const bookmarks = getBookmarks();
        if (bookmarks.length === 0) {
            alert('You have no bookmarked words to quiz!');
            return;
        }
        flashcardQuiz = shuffleArray([...bookmarks]);
        currentFlashcardIndex = 0;
        renderCurrentFlashcard();
        closeBookmarkModal();
        flashcardModal.classList.remove('hidden');
    };

    const closeFlashcardModal = () => {
        flashcardModal.classList.add('hidden');
        flashcardQuiz = [];
    };

    const renderCurrentFlashcard = () => {
        if (currentFlashcardIndex >= flashcardQuiz.length) {
            alert('Quiz complete! Well done!');
            closeFlashcardModal();
            return;
        }
        const cardData = flashcardQuiz[currentFlashcardIndex];
        flashcard.classList.remove('is-flipped');
        flashcardFront.textContent = cardData.originalWord;
        const synonymsHTML = cardData.synonyms.map(s => `<li>${s.word} <span class="translation">(${s.translation})</span></li>`).join('');
        flashcardBack.innerHTML = `
            <div class="flashcard-back-content">
                <div class="original">${cardData.originalWord} <span class="pos">(${cardData.pos})</span><span class="translation">(${cardData.meaning || cardData.translation || ''})</span></div>
                <ul class="bookmark-synonyms">${synonymsHTML}</ul>
            </div>
        `;
        flashcardProgress.textContent = `${currentFlashcardIndex + 1} / ${flashcardQuiz.length}`;
    };

    const deleteCurrentFlashcardAndAdvance = () => {
        if (flashcardQuiz.length === 0) return;
        const wordToDelete = flashcardQuiz[currentFlashcardIndex].originalWord;
        const contextToDelete = flashcardQuiz[currentFlashcardIndex].context_phrase;
        let currentBookmarks = getBookmarks();
        currentBookmarks = currentBookmarks.filter(b => !(b.originalWord === wordToDelete && b.context_phrase === contextToDelete));
        saveBookmarks(currentBookmarks);
        flashcardQuiz.splice(currentFlashcardIndex, 1);
        if (currentFlashcardIndex >= flashcardQuiz.length) {
            currentFlashcardIndex = flashcardQuiz.length - 1;
        }
        if (flashcardQuiz.length === 0) {
            alert('Quiz complete! Well done!');
            closeFlashcardModal();
            renderBookmarks();
            return;
        }
        renderCurrentFlashcard();
        renderBookmarks();
    };

    startFlashcardsButton.addEventListener('click', openFlashcardModal);
    closeFlashcardModalButton.addEventListener('click', closeFlashcardModal);
    flashcard.addEventListener('click', () => flashcard.classList.toggle('is-flipped'));
    nextFlashcardButton.addEventListener('click', () => {
        if (currentFlashcardIndex < flashcardQuiz.length - 1) {
            currentFlashcardIndex++;
            renderCurrentFlashcard();
        }
    });
    prevFlashcardButton.addEventListener('click', () => {
        if (currentFlashcardIndex > 0) {
            currentFlashcardIndex--;
            renderCurrentFlashcard();
        }
    });
    completeFlashcardButton.addEventListener('click', deleteCurrentFlashcardAndAdvance);
    document.addEventListener('keydown', (e) => {
        if (flashcardModal.classList.contains('hidden')) return;
        switch (e.key) {
            case 'ArrowRight': e.preventDefault(); nextFlashcardButton.click(); break;
            case 'ArrowLeft': e.preventDefault(); prevFlashcardButton.click(); break;
            case ' ':
            case 'ArrowUp':
            case 'ArrowDown':
                e.preventDefault();
                flashcard.click();
                break;
        }
    });

    // --- Modal Logic ---
    const openSettingsModal = () => settingsModal.classList.remove('hidden');
    const closeSettingsModal = () => {
        settingsModal.classList.add('hidden');
        // Reset developer zone view
        const loginContainer = document.getElementById('developer-login-container');
        if(loginContainer) loginContainer.classList.remove('hidden');
        developerMemoContainer.classList.add('hidden');
        devPasswordInput.value = '';
        devLoginFeedback.classList.remove('visible');
        isDevLoggedIn = false;
        devAccessLevel = null;
        devMemoPad.value = '';
        devMemoPad.setAttribute('readonly', true);
    };
    const openBookmarkModal = () => { renderBookmarks(); bookmarkModal.classList.remove('hidden'); };
    const closeBookmarkModal = () => bookmarkModal.classList.add('hidden');
    settingsButton.addEventListener('click', openSettingsModal);
    closeSettingsModalButton.addEventListener('click', closeSettingsModal);
    settingsModal.addEventListener('click', (e) => { if (e.target === settingsModal) closeSettingsModal(); });
    bookmarkListButton.addEventListener('click', openBookmarkModal);
    closeBookmarkModalButton.addEventListener('click', closeBookmarkModal);
    bookmarkModal.addEventListener('click', (e) => { if (e.target === bookmarkModal) closeBookmarkModal(); });

    // --- Paraphraser Pro Modal Logic ---
    const paraphraserButton = document.getElementById('paraphraser-button');
    const paraphraserModal = document.getElementById(\'paraphraser-modal\');\n    const closeParaphraserModalButton = document.getElementById(\'close-paraphraser-modal\');\n    const paraphraserInput = document.getElementById(\'paraphraser-input\');\n    const paraphraserOutput = document.getElementById(\'paraphraser-output\');\n    const paraphraseProcessButton = document.getElementById(\'paraphrase-process-button\');\n    const paraphraseCopyButton = document.getElementById(\'paraphrase-copy-button\');\n\n    const openParaphraserModal = () => paraphraserModal.classList.remove(\'hidden\');\n    const closeParaphraserModal = () => paraphraserModal.classList.add(\'hidden\');\n\n    paraphraserButton.addEventListener(\'click\', openParaphraserModal);\n    closeParaphraserModalButton.addEventListener(\'click\', closeParaphraserModal);\n    paraphraserModal.addEventListener(\'click\', (e) => { if (e.target === paraphraserModal) closeParaphraserModal(); });\n\n    paraphraseCopyButton.addEventListener(\'click\', () => {\n        const textToCopy = paraphraserOutput.value;\n        if (textToCopy) {\n            navigator.clipboard.writeText(textToCopy).then(() => {\n                const originalText = paraphraseCopyButton.textContent;\n                paraphraseCopyButton.textContent = \'Copied!\';\n                paraphraseCopyButton.disabled = true;\n                setTimeout(() => {\n                    paraphraseCopyButton.textContent = originalText;\n                    paraphraseCopyButton.disabled = false;\n                }, 2000);\n            }).catch(err => {\n                console.error(\'Failed to copy text: \', err);\n                alert(\'Failed to copy text.\');\n            });\n        }\n    });\n\n    const handleParaphrase = async () => {\n        if (!geminiApiKey) {\n            alert(\'Please set your Gemini API key in the settings first.\');\n            openSettingsModal();\n            return;\n        }\n\n        const inputText = paraphraserInput.value.trim();\n        if (!inputText) {\n            alert(\'Please enter some text to paraphrase.\');\n            return;\n        }\n\n        paraphraseProcessButton.disabled = true;\n        paraphraseProcessButton.textContent = \'Paraphrasing...\';\n        paraphraserOutput.value = \'\';\n\n        const paraphraserPrompt = `You are an expert paraphraser. Your goal is to rewrite the user\'s text to make it sound more human and less like it was written by an AI. Follow these instructions precisely:\\n\\n1.  **Vary Sentence Structure (Burstiness)**:\\n    *   Mix short, punchy sentences with longer, more complex ones.\\n    *   Break up uniform sentence lengths by splitting or merging sentences where appropriate.\\n\\n2.  **Diversify Word Choice (Perplexity)**:\\n    *   Avoid predictable, common AI-generated words.\\n    *   Introduce less common but contextually appropriate words to increase surprise and randomness.\\n\\n3.  **Eliminate AI-isms (Stylometry)**:\\n    *   Replace common AI phrases (e.g., \"Showcasing\", \"delve into\", \"Furthermore,\", \"It is worth noting that...\") with more natural alternatives (e.g., \"showing\", \"Also,\").\\n    *   Modify the use of pronouns, auxiliary verbs, and punctuation to match a more human style.\\n\\n4.  **Inject Human Imperfection (Cognitive & Rhetorical)**:\\n    *   Strategically start some sentences with \"And\" or \"But\".\\n    *   Include subjective markers like \"I believe,\" or \"In my experience,\" where it feels natural.\\n    *   Use hedging language like \"perhaps\" or \"it seems\" to soften overly confident or assertive tones.\\n\\n5.  **CRITICAL RULE: Do NOT use contractions.**\\n    *   Expand all contractions. For example, \"it\'s\" must become \"it is\", \"I\'m\" must become \"I am\", \"don\'t\" must become \"do not\", etc.\\n\\nNow, apply these rules to the following text:\\n\\n---\\n${inputText}\\n---\`;\n\n        const url = `https://generativelanguage.googleapis.com/v1beta/models/${selectedModel}:generateContent?key=${geminiApiKey}`;\n        const requestBody = { contents: [{ parts: [{ text: paraphraserPrompt }] }] };\n\n        try {\n            const response = await fetch(url, { method: \'POST\', headers: { \'Content-Type\': \'application/json\' }, body: JSON.stringify(requestBody) });\n            if (!response.ok) {\n                const errorData = await response.json();\n                const errorMessage = errorData.error?.message || \'Unknown API error\';\n                throw new Error(`API Error: ${errorMessage}`);\n            }\n            const data = await response.json();\n            const resultText = data.candidates[0]?.content?.parts[0]?.text;\n            if (!resultText) {\n                throw new Error(\'API returned an empty response.\');\n            }\n            paraphraserOutput.value = resultText.trim();\n        } catch (error) {\n            console.error(\'Paraphrasing error:\', error);\n            paraphraserOutput.value = `An error occurred: ${error.message}`;\n        }\n        finally {\n            paraphraseProcessButton.disabled = false;\n            paraphraseProcessButton.textContent = \'Paraphrase\';\n        }\n    };\n\n    paraphraseProcessButton.addEventListener(\'click\', handleParaphrase);

    // --- Word Counter & Clear ---
    textInput.addEventListener('input', () => {
        const wordCount = textInput.value.trim().split(/\s+/).filter(Boolean).length;
        wordCounter.textContent = `${wordCount} words`;
    });


    clearTextButton.addEventListener('click', () => {
        textInput.value = '';
        processedText.innerHTML = '';
        synonymList.innerHTML = '<p class="placeholder">Enter text to see synonyms.</p>';
        textInput.dispatchEvent(new Event('input', { bubbles: true }));
        textInput.style.zIndex = 1;
        processedText.style.zIndex = -1;
    });

    copyOutputButton.addEventListener('click', () => {
        const textToCopy = processedText.innerText;
        if (textToCopy) {
            navigator.clipboard.writeText(textToCopy).then(() => {
                const originalText = copyOutputButton.textContent;
                copyOutputButton.textContent = 'Copied!';
                copyOutputButton.disabled = true;
                setTimeout(() => {
                    copyOutputButton.textContent = originalText;
                    copyOutputButton.disabled = false;
                }, 2000);
            }).catch(err => {
                console.error('Failed to copy text: ', err);
                alert('Failed to copy text.');
            });
        }
    });

    aiDetectButton.addEventListener('click', async () => {
        if (!saplingApiKey) {
            alert('Please set your Sapling AI Detector API key in the settings first.');
            openSettingsModal();
            return;
        }

        const textToAnalyze = processedText.innerText;
        if (!textToAnalyze.trim()) {
            showNotification('AI Detect', 'No text found in the output area to analyze.');
            return;
        }

        // Store original content to revert after highlighting
        const originalProcessedTextContent = processedText.innerHTML;

        showProgressBar();
        setProgress(10, 'Analyzing text for AI content...');
        startMessageInterval(30); // Estimate 30 seconds for AI detection

        const aiDetectResult = await detectAiContent(textToAnalyze);
        stopAllIntervals();
        hideProgressBar();

        if (aiDetectResult.status === 'error') {
            showNotification('AI Detection Error', aiDetectResult.message);
            return;
        }

        const score = aiDetectResult.data.score; // 0 = human, 1 = AI
        const scorePercentage = (score * 100).toFixed(2);
        const scoreStringHtml = aiDetectResult.data.score_string;

        if (scoreStringHtml) {
            // Display highlighted text for 10 seconds
            processedText.innerHTML = scoreStringHtml;
            showNotification('AI Detection Result', `AI Detection Score: ${scorePercentage}% AI-generated.\nHighlighted parts indicate AI-generated content.`);

            setTimeout(() => {
                // Revert to original content after 10 seconds
                processedText.innerHTML = originalProcessedTextContent;
            }, 10000); // 10 seconds
        } else {
            showNotification('AI Detection Result', `AI Detection Score: ${scorePercentage}% AI-generated.`);
        }
    });

    // --- Progress Bar Logic ---
    function setProgress(percentage, message = '') { progressBar.style.width = `${percentage}%`; if (message) progressMessage.textContent = message; }
    function showProgressBar() { progressContainer.classList.remove('hidden'); }
    function hideProgressBar(delay = 500) { setTimeout(() => { progressContainer.classList.add('hidden'); }, delay); }
    function startMessageInterval(expectedTime) { stopMessageInterval(); messageIntervalId = setInterval(() => { progressMessage.classList.add('fading-out'); setTimeout(() => { const randomIndex = Math.floor(Math.random() * loadingMessages.length); progressMessage.textContent = `${loadingMessages[randomIndex]} (est. ${expectedTime}s)`; progressMessage.classList.remove('fading-out'); }, 500); }, 3000); }
    function stopMessageInterval() { if (messageIntervalId) { clearInterval(messageIntervalId); messageIntervalId = null; } }
    function startProgressBar(duration) { stopProgressBar(); let currentProgress = 0; progressBar.style.width = '0%'; const incrementMillis = 100; const totalSteps = duration * 1000 / incrementMillis; const step = 99 / totalSteps; progressIntervalId = setInterval(() => { currentProgress += step; if (currentProgress >= 99) { currentProgress = 99; stopProgressBar(); } progressBar.style.width = `${currentProgress}%`; }, incrementMillis); } 
    function stopProgressBar() { if (progressIntervalId) { clearInterval(progressIntervalId); progressIntervalId = null; } }
    function stopAllIntervals() { stopMessageInterval(); stopProgressBar(); }

    // --- Theme Switcher Logic ---
    function applyTheme(themeName) {
        const themeClasses = ['light-theme', 'dark-theme', 'nord-theme', 'glass-theme'];
        document.body.classList.remove('light-mode', ...themeClasses);

        if (themeName && themeName !== 'light') {
            document.body.classList.add(`${themeName}-theme`);
        } else {
            document.body.classList.add('light-theme');
        }

        // Special handling for glass theme
        document.querySelectorAll('.panel, .modal-content, .flashcard-front, .flashcard-back').forEach(el => {
            el.classList.remove('glass-effect');
        });
        if (themeName === 'glass') {
            document.querySelectorAll('.panel, .modal-content, .flashcard-front, .flashcard-back').forEach(el => {
                el.classList.add('glass-effect');
            });
        }
    }

    function updateSelectedThemeButton(themeName) {
        themePreviewButtons.forEach(button => {
            button.classList.toggle('selected', button.dataset.theme === themeName);
        });
    }

    function loadTheme() {
        const savedTheme = localStorage.getItem('theme') || 'light';
        applyTheme(savedTheme);
        updateSelectedThemeButton(savedTheme);
    }

    themePreviewButtons.forEach(button => {
        button.addEventListener('click', (e) => {
            const selectedTheme = e.currentTarget.dataset.theme;
            applyTheme(selectedTheme);
            localStorage.setItem('theme', selectedTheme); // Save theme to local storage
            updateSelectedThemeButton(selectedTheme);
            saveUserData(); // Sync settings with Firestore for logged-in user
        });
    });

    // --- Model Selection Logic ---
    function updateSelectedModelButton() {
        modelSelectButtons.forEach(button => {
            button.classList.toggle('selected', button.dataset.model === selectedModel);
        });
    }

    function loadModel() {
        selectedModel = localStorage.getItem('ai_humanizer_selected_model') || 'gemini-2.5-flash-lite';
        updateSelectedModelButton();
    }

    modelSelectButtons.forEach(button => {
        button.addEventListener('click', (e) => {
            selectedModel = e.currentTarget.dataset.model;
            localStorage.setItem('ai_humanizer_selected_model', selectedModel);
            updateSelectedModelButton();
            saveUserData();
        });
    });

    // --- Translation Language Logic ---
    function loadTranslationLanguage() {
        const savedLanguage = localStorage.getItem('translationLanguage') || 'Japanese';
        selectedTranslationLanguage = savedLanguage;
        translationLanguageSelect.value = savedLanguage;
    }

    translationLanguageSelect.addEventListener('change', (e) => {
        selectedTranslationLanguage = e.target.value;
        localStorage.setItem('translationLanguage', selectedTranslationLanguage);
        saveUserData();
    });

    // --- Layout Mode Logic ---
    function applyLayoutMode(isVertical) {
        document.body.classList.toggle('vertical-layout', isVertical);
        layoutModeToggle.checked = isVertical;
        localStorage.setItem('layoutMode', isVertical);
        saveUserData();
    }

    function loadLayoutMode() {
        const savedLayout = localStorage.getItem('layoutMode') === 'true';
        applyLayoutMode(savedLayout);
    }

    layoutModeToggle.addEventListener('change', (e) => applyLayoutMode(e.target.checked));

    // --- Helper for SHA-256 Hashing ---
    async function sha256(message) {
        const msgBuffer = new TextEncoder().encode(message);
        const hashBuffer = await crypto.subtle.digest('SHA-256', msgBuffer);
        const hashArray = Array.from(new Uint8Array(hashBuffer));
        const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
        return hashHex;
    }

    // --- Developer Zone Logic ---
    const devPasswords = {
        '0fc2e3d4c35968ee6f4b627b496736dc232c9422c63ffc96118f04222c0404c1': 'readonly', // israpicodeisr
        'a24125089ac9f110389cb6dd4b8a3195cbf12b531ceef7ad8b787e9cd372f9fb': 'readwrite' // MSena19231230
    };
    let devAccessLevel = null;
    const memoDocRef = doc(db, 'devMemos', 'apiMemo');

    devLoginButton.addEventListener('click', async () => {
        const password = devPasswordInput.value;
        if (!password) return;
        const inputPassHash = await sha256(password);
        const accessLevel = devPasswords[inputPassHash];

        if (accessLevel) {
            devAccessLevel = accessLevel;
            isDevLoggedIn = true;

            try {
                const docSnap = await getDoc(memoDocRef);
                if (docSnap.exists()) {
                    devMemoPad.value = docSnap.data().content || '';
                } else {
                    // If the document doesn't exist, create it with a default message
                    await setDoc(memoDocRef, { content: 'Welcome to the developer memo. Start typing here...' });
                    devMemoPad.value = 'Welcome to the developer memo. Start typing here...';
                }
            } catch (error) {
                console.error("Error fetching dev memo: ", error);
                devMemoPad.value = 'Error fetching memo.';
            }

            // Hide the login form and show the memo container
            const loginContainer = document.getElementById('developer-login-container');
            if(loginContainer) loginContainer.classList.add('hidden');
            developerMemoContainer.classList.remove('hidden');

            if (accessLevel === 'readonly') {
                devMemoPad.setAttribute('readonly', true);
            } else {
                devMemoPad.removeAttribute('readonly');
            }

        } else {
            devLoginFeedback.textContent = 'Invalid credentials.';
            devLoginFeedback.style.color = '#dc3545';
            devPasswordInput.value = '';
            devLoginFeedback.classList.add('visible');
            setTimeout(() => { devLoginFeedback.classList.remove('visible'); }, 2000);
        }
    });

    devMemoPad.addEventListener('input', async () => {
        if (devAccessLevel === 'readwrite') {
            try {
                // Use setDoc with merge:true to avoid overwriting other fields if they exist
                await setDoc(memoDocRef, { content: devMemoPad.value }, { merge: true });
            } catch (error) {
                console.error("Error auto-saving dev memo: ", error);
            }
        }
    });



    // --- API Key ---
    saveApiKeyButton.addEventListener('click', () => {
        const feedbackElement = document.getElementById('save-api-key-feedback');
        const key = apiKeyInput.value.trim();
        if (key) {
            localStorage.setItem('geminiApiKey', key);
            geminiApiKey = key;
            saveUserData(); // Sync settings with Firestore for logged-in user
            feedbackElement.textContent = 'API Key Saved!';
            feedbackElement.style.color = '#28a745';
            feedbackElement.classList.add('visible');
            setTimeout(() => { feedbackElement.classList.remove('visible'); closeSettingsModal(); }, 1500);
        } else {
            feedbackElement.textContent = 'Please enter a valid API key.';
            feedbackElement.style.color = '#dc3545';
            feedbackElement.classList.add('visible');
            setTimeout(() => { feedbackElement.classList.remove('visible'); }, 2000);
        }
    });

    saveSaplingApiKeyButton.addEventListener('click', () => {
        const feedbackElement = saveSaplingApiKeyFeedback;
        const key = saplingApiKeyInput.value.trim();
        if (key) {
            localStorage.setItem('saplingApiKey', key);
            saplingApiKey = key;
            saveUserData(); // Sync settings with Firestore for logged-in user
            feedbackElement.textContent = 'Sapling API Key Saved!';
            feedbackElement.style.color = '#28a745';
            feedbackElement.classList.add('visible');
            setTimeout(() => { feedbackElement.classList.remove('visible'); closeSettingsModal(); }, 1500);
        } else {
            feedbackElement.textContent = 'Please enter a valid Sapling API key.';
            feedbackElement.style.color = '#dc3545';
            feedbackElement.classList.add('visible');
            setTimeout(() => { feedbackElement.classList.remove('visible'); }, 2000);
        }
    });

    function loadApiKey() {
        const savedKey = localStorage.getItem('geminiApiKey');
        if (savedKey) {
            geminiApiKey = savedKey;
            apiKeyInput.value = savedKey;
        } else {
            // Only open settings if Gemini API key is missing
            // openSettingsModal();
        }
    }

    function loadSaplingApiKey() {
        const savedKey = localStorage.getItem('saplingApiKey');
        if (savedKey) {
            saplingApiKey = savedKey;
            saplingApiKeyInput.value = savedKey;
        }
    }

    // --- API & Main Processing Logic ---
    async function extractWordsAndPhrases(text, sourceLanguage) {
        // Explicitly escape newline characters for the prompt to ensure they are preserved.
        const sanitizedText = text.replace(/\n/g, '\\n');
        const url = `https://generativelanguage.googleapis.com/v1beta/models/${selectedModel}:generateContent?key=${geminiApiKey}`;
        let prompt;
        if (sourceLanguage === 'Japanese' || sourceLanguage === 'Chinese') {
            // For non-spaced languages, avoid asking for 'spaces' as separate components
            // and clarify newline handling
            prompt = `Analyze the following text in ${sourceLanguage} and extract a comprehensive list of its meaningful linguistic units. Include individual words, punctuation, and explicit newline characters (\\n) ONLY if they are present in the original text as separate elements in the array. Preserve the original order and casing. Return the result as a single JSON array of strings.\n\nText: "吾輩は猫である。名前はまだない。\\nどこで生まれたか頓と見当がつかぬ。"\n\nExample Output:
["吾輩", "は", "猫", "である", "。", "\\n", "名前", "は", "まだ", "ない", "。", "\\n", "どこで", "生まれたか", "頓と", "見当が", "つかぬ", "。"]

Your turn. Text: "${sanitizedText}"`;
        } else {
            // For spaced languages, include spaces as separate components
            prompt = `Analyze the following text in ${sourceLanguage} and extract a comprehensive list of all its meaningful components. It is crucial that you include individual words, punctuation, spaces, and explicit newline characters (\\n) ONLY if they are present in the original text as separate elements in the array. Preserve the original order and casing. Return the result as a single JSON array of strings.\n\nText: "He decided to give up.\\nThen he looked for a new job."\n\nExample Output:
["He", " ", "decided", " ", "to", " ", "give up", ".", "\\n", "Then", " ", "he", " ", "looked for", " ", "a", " ", "new", " ", "job", "."]

Your turn. Text: "${sanitizedText}"`;
        }
        const requestBody = { contents: [{ parts: [{ text: prompt }] }], generationConfig: { "response_mime_type": "application/json" } };
        try {
            const response = await fetch(url, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(requestBody) });
            if (!response.ok) return { status: 'error', message: 'Failed to extract phrases from API.' };
            const data = await response.json();
            const resultText = data.candidates[0]?.content?.parts[0]?.text;
            if (!resultText) return { status: 'error', message: 'API returned empty response for phrase extraction.' };
            const cleanedText = resultText.replace(/```json\n|```/g, '').replace(/[ --]/g, '').trim();
            return { status: 'success', data: JSON.parse(cleanedText) };
        } catch (error) {
            console.error('Phrase extraction error:', error);
            return { status: 'error', message: 'Network error or other issue.' };
        }
    }

    // --- Language Detection Function ---
    async function detectLanguage(text) {
        const url = `https://generativelanguage.googleapis.com/v1beta/models/${selectedModel}:generateContent?key=${geminiApiKey}`;
        const prompt = `Detect the language of the following text. Respond with only the name of the language in English (e.g., "English", "Japanese", "German", "Spanish", "Chinese", "Hindi", "Portuguese", "Russian"). If the language cannot be confidently detected, respond with "Unknown".\n\nText: "${text}"`;
        const requestBody = { contents: [{ parts: [{ text: prompt }] }] };
        try {
            const response = await fetch(url, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(requestBody) });
            if (!response.ok) return 'Unknown';
            const data = await response.json();
            const detectedLang = data.candidates[0]?.content?.parts[0]?.text.trim();
            return detectedLang || 'Unknown';
        } catch (error) {
            console.error('Language detection error:', error);
            return 'Unknown';
        }
    }

    // --- AI Content Detection Function ---
    async function detectAiContent(text) {
        if (!saplingApiKey) {
            return { status: 'error', message: 'Sapling API key is not set.' };
        }
        const url = 'https://api.sapling.ai/api/v1/aidetect';
        const requestBody = {
            key: saplingApiKey,
            text: text,
            score_string: true, // Request highlighted HTML
            version: '20240606' // Use the latest version
        };

        try {
            const response = await fetch(url, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(requestBody)
            });

            if (!response.ok) {
                const errorData = await response.json();
                const errorMessage = errorData.detail || errorData.message || 'Unknown API error from Sapling.';
                return { status: 'error', message: `Sapling API Error: ${errorMessage}` };
            }

            const data = await response.json();
            return { status: 'success', data: data };

        } catch (error) {
            console.error('Sapling AI detection error:', error);
            return { status: 'error', message: 'Network error or other issue with Sapling API.' };
        }
    }

    async function fetchSynonymsInBatch(words, text, sourceLanguage, translationLanguage) {
        const url = `https://generativelanguage.googleapis.com/v1beta/models/${selectedModel}:generateContent?key=${geminiApiKey}`;
        const prompt = `Given the following full text in ${sourceLanguage}:
"""
${text}
"""

For each word/phrase in the following JSON array, analyze all its occurrences within the full text and provide contextual information.
Words to analyze: ${JSON.stringify(words)}

Return a single JSON object. The keys of this object should be the original words/phrases.
The value for each key must be an array of objects, where each object represents a distinct meaning of the word in the text based on its context.
Each object in the array must have the following structure:
{
  "pos": "The specific part of speech in context (e.g., \"Noun\", \"Verb\").",
  "meaning": "A brief ${translationLanguage} definition of the word in that context.",
  "context_phrase": "A short snippet from the text showing the word in context.",
  "synonyms": "An array of exactly 3 synonym objects in ${sourceLanguage} if possible. If 3 are not available, provide as many as you can. Each object should have a 'word' and a 'translation' (in ${translationLanguage}) key."
}

Example for the word 'book' in 'I need to book a flight to read a book.' (Source: English, Translation: Japanese):
"book": [
  { "pos": "Verb", "meaning": "予約する", "context_phrase": "...to book a flight...", "synonyms": [{ "word": "reserve", "translation": "予約する" }, { "word": "schedule", "translation": "予定する" }] },
  { "pos": "Noun", "meaning": "本", "context_phrase": "...read a book.", "synonyms": [{ "word": "volume", "translation": "巻" }, { "word": "publication", "translation": "出版物" }] }
]
`;
        const requestBody = { contents: [{ parts: [{ text: prompt }] }], generationConfig: { "response_mime_type": "application/json" } };
        try {
            const response = await fetch(url, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(requestBody) });
            if (!response.ok) {
                 const errorData = await response.json();
                 const errorMessage = errorData.error?.message || 'Unknown API error';
                 return { status: 'error', message: `API Error: ${errorMessage}` };
            }
            const data = await response.json();
            const resultText = data.candidates[0]?.content?.parts[0]?.text;
            if (resultText) {
                const cleanedText = resultText.replace(/```json\n|```/g, '').replace(/[ --]/g, '').trim();
                return { status: 'success', data: JSON.parse(cleanedText) };
            } else {
                return { status: 'error', message: 'API returned empty response.' };
            }
        } catch (error) {
            console.error('Fetch or other error:', error);
            return { status: 'error', message: 'Network error or other issue.' };
        }
    }

    function renderSynonymCandidates(synonymData, parts) {
        synonymList.innerHTML = '';
        processedText.innerHTML = '';
        let wordIdCounter = 0;
        let replaceableFound = false;
        const wordUsageCount = {};
        parts.forEach(part => {
            const meanings = synonymData[part];
            if (meanings && meanings.length > 0) {
                const usageIndex = wordUsageCount[part] || 0;
                const data = meanings[usageIndex % meanings.length];
                wordUsageCount[part] = usageIndex + 1;
                if (data && data.synonyms && data.synonyms.length > 0) {
                    replaceableFound = true;
                    wordIdCounter++;
                    const wordId = `word-${wordIdCounter}`;
                    const groupId = `group-${wordIdCounter}`;
                    const span = document.createElement('span');
                    span.textContent = part;
                    span.id = wordId;
                    span.className = 'replaceable';
                    span.dataset.originalWord = part;
                    span.addEventListener('click', () => { 
                        const groupElement = document.getElementById(groupId); 
                        groupElement.scrollIntoView({ behavior: 'smooth', block: 'center' }); 
                        groupElement.classList.add('scrolled-highlight'); 
                        setTimeout(() => groupElement.classList.remove('scrolled-highlight'), 3500); 
                    });
                    span.addEventListener('contextmenu', (e) => { 
                        e.preventDefault(); 
                        const targetSpan = e.target; 
                        const original = targetSpan.dataset.originalWord; 
                        if (targetSpan.textContent !== original) { 
                            targetSpan.textContent = original; 
                            targetSpan.classList.remove('modified'); 
                            const groupElement = document.getElementById(groupId); 
                            const allItems = groupElement.querySelectorAll('.synonym-item, .original-word'); 
                            allItems.forEach(item => item.classList.remove('selected')); 
                            groupElement.querySelector('.original-word').classList.add('selected'); 
                        } 
                    });
                    processedText.appendChild(span);
                    createSynonymGroup(part, data, wordId, groupId);
                } else {
                    if (/^\n+$/.test(part)) {
                        for (let i = 0; i < part.length; i++) {
                            processedText.appendChild(document.createElement('br'));
                        }
                    } else {
                        processedText.appendChild(document.createTextNode(part));
                    }
                }
            } else {
                if (/^\n+$/.test(part)) {
                    for (let i = 0; i < part.length; i++) {
                        processedText.appendChild(document.createElement('br'));
                    }
                } else {
                    processedText.appendChild(document.createTextNode(part));
                }
            }
        });
        if (!replaceableFound) {
            synonymList.innerHTML = '<p class="placeholder">No synonyms found for the words in your text.</p>';
        }
    }

    function createSynonymGroup(originalWord, data, wordId, groupId) {
        const group = document.createElement('div');
        group.id = groupId;
        group.className = 'synonym-group';
        const bookmarkBtn = document.createElement('i');
        const bookmarks = getBookmarks();
        const isBookmarked = bookmarks.some(b => b.originalWord === originalWord && b.context_phrase === data.context_phrase);
        bookmarkBtn.className = `bookmark-btn ${isBookmarked ? 'fas fa-bookmark' : 'far fa-bookmark'}`;
        bookmarkBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            let currentBookmarks = getBookmarks();
            const alreadyExistsIndex = currentBookmarks.findIndex(b => b.originalWord === originalWord && b.context_phrase === data.context_phrase);
            if (alreadyExistsIndex > -1) {
                currentBookmarks.splice(alreadyExistsIndex, 1);
                bookmarkBtn.className = 'bookmark-btn far fa-bookmark';
            } else {
                const newBookmark = { originalWord, pos: data.pos, meaning: data.meaning, context_phrase: data.context_phrase, synonyms: data.synonyms };
                currentBookmarks.push(newBookmark);
                bookmarkBtn.className = 'bookmark-btn fas fa-bookmark';
            }
            saveBookmarks(currentBookmarks);
        });
        group.appendChild(bookmarkBtn);
        group.addEventListener('mouseenter', () => document.getElementById(wordId).classList.add('highlight'));
        group.addEventListener('mouseleave', () => document.getElementById(wordId).classList.remove('highlight'));
        const originalWordEl = document.createElement('div');
        originalWordEl.className = 'original-word selected';
        originalWordEl.innerHTML = `${originalWord} <span class="pos">(${data.pos || ''})</span> <span class="translation">(${data.meaning || data.translation || ''})</span>`;
        group.appendChild(originalWordEl);
        const allClickableItems = [originalWordEl];
        data.synonyms.slice(0, 3).forEach(syn => { 
            const item = document.createElement('div'); 
            item.className = 'synonym-item'; 
            item.innerHTML = `<span class="synonym-word">${syn.word}</span> <span class="translation">(${syn.translation || ''})</span>`; 
            group.appendChild(item); 
            allClickableItems.push(item); 
        });
        allClickableItems.forEach(item => { 
            item.addEventListener('click', (e) => {
                allClickableItems.forEach(i => i.classList.remove('selected'));
                const clickedItem = e.currentTarget;
                clickedItem.classList.add('selected');
                const wordSpan = document.getElementById(wordId);
                const newWord = clickedItem.querySelector('.synonym-word')?.textContent || originalWord;
                wordSpan.textContent = newWord;
                if (newWord === originalWord) {
                    wordSpan.classList.remove('modified');
                } else {
                    wordSpan.classList.add('modified');
                }
            }); 
        });
        synonymList.appendChild(group);
    }

    processButton.addEventListener('click', async () => {
        if (!checkUsageLimit()) return;
        if (!geminiApiKey) { alert('Please set your Gemini API key in the settings first.'); openSettingsModal(); return; }
        const text = textInput.value;
        if (!text.trim()) return;
        recordUsage();
        const roughWordCount = text.trim().split(/\s+/).length;
        const expectedTime = Math.round(15 + roughWordCount * 1.2);
        let isProcessing = true;
        showProgressBar();
        setProgress(5, `Initializing... (est. ${expectedTime}s)`);
        startMessageInterval(expectedTime);
        startProgressBar(expectedTime);

        // Step 1: Detect Language
        setProgress(10, 'Step 1/3: Detecting language...');
        const sourceLanguage = await detectLanguage(text);
        if (sourceLanguage === 'Unknown') {
            alert('Could not confidently detect the language of the text. Please try again with more text or a different language.');
            hideProgressBar();
            stopAllIntervals();
            return;
        }

        // Step 2: Analyze text structure
        setProgress(35, `Step 2/3: Analyzing text structure in ${sourceLanguage}...`);
        const phraseExtractionResult = await extractWordsAndPhrases(text, sourceLanguage);
        if (phraseExtractionResult.status === 'error') {
            alert(phraseExtractionResult.message);
            hideProgressBar();
            stopAllIntervals();
            return;
        }
        const parts = phraseExtractionResult.data;
        const uniqueWordsAndPhrases = [...new Set(parts.filter(p => {
            const lowerCasePart = p.toLowerCase();
            // Filter for words that are likely to have synonyms in the source language
            // Removed p.match(/[a-zA-Z]/) to support non-English languages
            return p.trim() !== '' && !stopWords.has(lowerCasePart);
        }))];
        const timeoutId = setTimeout(() => { if (isProcessing) { stopMessageInterval(); setProgress(99, 'May take some extra time...'); } }, expectedTime * 1000);
        textInput.style.zIndex = -1;
        processedText.style.zIndex = 1;
        if (uniqueWordsAndPhrases.length === 0) {
            renderSynonymCandidates({}, parts);
            addHistoryItem(text, parts, {});
            isProcessing = false;
            clearTimeout(timeoutId);
            stopAllIntervals();
            hideProgressBar();
            return;
        }

        // Step 3: Fetch contextual synonyms
        setProgress(70, `Step 3/3: Fetching contextual synonyms in ${sourceLanguage} (translating to ${selectedTranslationLanguage})...`);
        const result = await fetchSynonymsInBatch(uniqueWordsAndPhrases, text, sourceLanguage, selectedTranslationLanguage);
        isProcessing = false;
        clearTimeout(timeoutId);
        stopAllIntervals();
        if (result.status === 'error') {
            alert(result.message || 'An unknown error occurred.');
            synonymList.innerHTML = `<p class="placeholder">${result.message}</p>`;
            processedText.innerHTML = text.replace(/\n/g, '<br>');
            hideProgressBar();
            return;
        }
        const synonymData = result.data;
        renderSynonymCandidates(synonymData, parts);
        addHistoryItem(text, parts, synonymData);
        setProgress(100, 'Done!');
        hideProgressBar(1500);
    });

    // --- Initialization ---
    loadApiKey();
    loadTheme();
    loadLayoutMode();
    loadModel();
    loadTranslationLanguage();
    loadSaplingApiKey();
    textInput.style.zIndex = 1;
    processedText.style.zIndex = -1;
});